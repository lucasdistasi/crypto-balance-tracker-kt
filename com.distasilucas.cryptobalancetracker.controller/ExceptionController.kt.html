<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionController.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crypto-balance-tracker</a> &gt; <a href="index.source.html" class="el_package">com.distasilucas.cryptobalancetracker.controller</a> &gt; <span class="el_source">ExceptionController.kt</span></div><h1>ExceptionController.kt</h1><pre class="source lang-java linenums">package com.distasilucas.cryptobalancetracker.controller

import com.distasilucas.cryptobalancetracker.constants.INVALID_VALUE_FOR
import com.distasilucas.cryptobalancetracker.constants.UNKNOWN_ERROR
import com.distasilucas.cryptobalancetracker.exception.ApiException
import com.distasilucas.cryptobalancetracker.exception.TooManyRequestsException
import com.distasilucas.cryptobalancetracker.model.SortBy
import com.distasilucas.cryptobalancetracker.model.SortType
import com.distasilucas.cryptobalancetracker.service.*
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.validation.ConstraintViolationException
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.security.access.AccessDeniedException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.MissingServletRequestParameterException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.context.request.ServletWebRequest
import org.springframework.web.context.request.WebRequest
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.net.URI

<span class="fc" id="L26">@RestControllerAdvice</span>
<span class="fc" id="L27">class ExceptionController {</span>

<span class="fc" id="L29">    private val logger = KotlinLogging.logger { }</span>
<span class="fc" id="L30">    private val NOT_FOUND_STATUS = HttpStatus.NOT_FOUND</span>
<span class="fc" id="L31">    private val BAD_REQUEST_STATUS = HttpStatus.BAD_REQUEST</span>

    @ExceptionHandler(PlatformNotFoundException::class)
    fun handlePlatformNotFoundException(
        exception: PlatformNotFoundException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L38">        logger.info { &quot;A PlatformNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L40">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L41">        val problemDetail =</span>
<span class="fc" id="L42">            NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L44">        return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(CoingeckoCryptoNotFoundException::class)
    fun handleCoingeckoCryptoNotFoundException(
        exception: CoingeckoCryptoNotFoundException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L52">        logger.info { &quot;A CoingeckoCryptoNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L54">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L55">        val problemDetail =</span>
<span class="fc" id="L56">            NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L58">        return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(UserCryptoNotFoundException::class)
    fun handleUserCryptoNotFoundException(
        exception: UserCryptoNotFoundException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L66">        logger.info { &quot;A UserCryptoNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L68">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L69">        val problemDetail =</span>
<span class="fc" id="L70">            NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L72">        return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(GoalNotFoundException::class)
    fun handleGoalNotFoundException(
        exception: GoalNotFoundException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L80">        logger.info { &quot;A GoalNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L82">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L83">        val problemDetail =</span>
<span class="fc" id="L84">            NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L86">        return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(DuplicatedPlatformException::class)
    fun handleDuplicatedPlatformException(
        exception: DuplicatedPlatformException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L94">        logger.info { &quot;A DuplicatedPlatformException occurred $exception&quot; }</span>

<span class="fc" id="L96">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L97">        val problemDetail =</span>
<span class="fc" id="L98">            BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L100">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(DuplicatedCryptoPlatFormException::class)
    fun handleDuplicatedCryptoPlatFormException(
        exception: DuplicatedCryptoPlatFormException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L108">        logger.info { &quot;A DuplicatedCryptoPlatFormException occurred $exception&quot; }</span>

<span class="fc" id="L110">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L111">        val problemDetail =</span>
<span class="fc" id="L112">            BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L114">        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(DuplicatedGoalException::class)
    fun handleDuplicatedGoalException(
        exception: DuplicatedGoalException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L122">        logger.info { &quot;A DuplicatedGoalException occurred $exception&quot; }</span>

<span class="fc" id="L124">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L125">        val problemDetail =</span>
<span class="fc" id="L126">            BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L128">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(InsufficientBalanceException::class)
    fun handleInsufficientBalanceException(
        exception: InsufficientBalanceException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L136">        logger.info { &quot;An InsufficientBalanceException occurred $exception&quot; }</span>

<span class="fc" id="L138">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L139">        val problemDetail =</span>
<span class="fc" id="L140">            HttpStatus.BAD_REQUEST.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L142">        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(UsernameNotFoundException::class)
    fun handleUsernameNotFoundException(
        exception: UsernameNotFoundException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L150">        logger.info { &quot;An UsernameNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L152">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L153">        val problemDetail =</span>
<span class="fc" id="L154">            HttpStatus.NOT_FOUND.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L156">        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(TooManyRequestsException::class)
    fun handleTooManyRequestsException(
        exception: TooManyRequestsException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L164">        logger.warn { &quot;A TooManyRequestsException occurred $exception&quot; }</span>

<span class="fc" id="L166">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L167">        val problemDetail =</span>
<span class="fc" id="L168">            HttpStatus.TOO_MANY_REQUESTS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L170">        return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValidException(
        exception: MethodArgumentNotValidException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L178">        logger.info { &quot;A MethodArgumentNotValidException occurred $exception&quot; }</span>

<span class="fc" id="L180">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L181">        val problemDetails = exception.allErrors.map {</span>
<span class="fc" id="L182">            HttpStatus.BAD_REQUEST.withDetailsAndURI(</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                it.defaultMessage ?: UNKNOWN_ERROR,</span>
<span class="fc" id="L184">                URI.create(request.requestURL.toString())</span>
            )
        }

<span class="fc" id="L188">        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problemDetails)</span>
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleHttpMessageNotReadableException(
        exception: HttpMessageNotReadableException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L196">        logger.info { &quot;A HttpMessageNotReadableException occurred $exception&quot; }</span>

<span class="fc" id="L198">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L199">        val problemDetail = ProblemDetail.forStatus(BAD_REQUEST_STATUS)</span>
<span class="fc" id="L200">        problemDetail.type = URI.create(request.requestURL.toString())</span>

<span class="fc" id="L202">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        exception: ConstraintViolationException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L210">        logger.info { &quot;A ConstraintViolationException occurred $exception&quot; }</span>

<span class="fc" id="L212">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L213">        val constraintViolations = exception.constraintViolations.toList()</span>

<span class="fc" id="L215">        val problemDetails = constraintViolations.map {</span>
<span class="fc" id="L216">            BAD_REQUEST_STATUS.withDetailsAndURI(it.message, URI.create(request.requestURL.toString()))</span>
        }

<span class="fc" id="L219">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(problemDetails)</span>
    }

    @ExceptionHandler(MissingServletRequestParameterException::class)
    fun handleMissingServletRequestParameterException(
        exception: MissingServletRequestParameterException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L227">        logger.info { &quot;A MissingServletRequestParameterException occurred $exception&quot; }</span>

<span class="fc" id="L229">        val request = (webRequest as ServletWebRequest).request</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        val detail = exception.body.detail ?: exception.message</span>
<span class="fc" id="L231">        val problemDetail = BAD_REQUEST_STATUS.withDetailsAndURI(detail, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L233">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(AccessDeniedException::class)
    fun handleAccessDeniedException(
        exception: AccessDeniedException,
        webRequest: WebRequest
    ): ResponseEntity&lt;ProblemDetail&gt; {
<span class="fc" id="L241">        logger.info { &quot;An AccessDeniedException occurred $exception&quot; }</span>

<span class="fc" id="L243">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        val detail = exception.message ?: &quot;Forbidden&quot;</span>
<span class="fc" id="L245">        val problemDetail = HttpStatus.FORBIDDEN.withDetailsAndURI(detail, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L247">        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(problemDetail)</span>
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleMethodArgumentTypeMismatchException(
            exception: MethodArgumentTypeMismatchException,
            webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L255">        logger.info { &quot;A MethodArgumentTypeMismatchException occurred $exception&quot; }</span>

<span class="fc" id="L257">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L258">        val name = exception.name</span>
<span class="fc" id="L259">        val availableValues = getAvailableValues(name)</span>
<span class="fc" id="L260">        val message = INVALID_VALUE_FOR.format(exception.value, name, availableValues)</span>
<span class="fc" id="L261">        val problemDetail = BAD_REQUEST_STATUS.withDetailsAndURI(message, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L263">        return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(ApiException::class)
    fun handleApiException(
        exception: ApiException,
        webRequest: WebRequest
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L271">        logger.warn { &quot;An ApiException occurred $exception&quot; }</span>

<span class="fc" id="L273">        val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L274">        val httpStatusCode = exception.httpStatusCode</span>

<span class="fc" id="L276">        val problemDetail = ProblemDetail.forStatusAndDetail(httpStatusCode, exception.message!!)</span>
<span class="fc" id="L277">        problemDetail.type = URI.create(request.requestURL.toString())</span>

<span class="fc" id="L279">        return ResponseEntity.status(httpStatusCode).body(listOf(problemDetail))</span>
    }

    @ExceptionHandler(Exception::class)
    fun handleException(
        exception: Exception
    ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L286">        logger.warn { &quot;An unhandled Exception occurred $exception&quot; }</span>

<span class="fc" id="L288">        val problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.INTERNAL_SERVER_ERROR, UNKNOWN_ERROR)</span>

<span class="fc" id="L290">        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(listOf(problemDetail))</span>
    }

    private fun HttpStatus.withDetailsAndURI(
        detail: String,
        type: URI
    ): ProblemDetail {
<span class="fc" id="L297">        val problemDetail = ProblemDetail.forStatusAndDetail(this, detail)</span>
<span class="fc" id="L298">        problemDetail.type = type</span>

<span class="fc" id="L300">        return problemDetail</span>
    }

    private fun getAvailableValues(enumParamName: String): String {
<span class="fc" id="L304">        return when (enumParamName) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            &quot;sortBy&quot; -&gt; SortBy.entries.toTypedArray().contentToString()</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">            &quot;sortType&quot; -&gt; SortType.entries.toTypedArray().contentToString()</span>
<span class="fc" id="L307">            else -&gt; &quot;&quot;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>