<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionController.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">crypto-balance-tracker</a> &gt; <a href="index.source.html" class="el_package">com.distasilucas.cryptobalancetracker.controller</a> &gt; <span class="el_source">ExceptionController.kt</span></div><h1>ExceptionController.kt</h1><pre class="source lang-java linenums">package com.distasilucas.cryptobalancetracker.controller

import com.distasilucas.cryptobalancetracker.constants.INVALID_VALUE_FOR
import com.distasilucas.cryptobalancetracker.constants.UNKNOWN_ERROR
import com.distasilucas.cryptobalancetracker.exception.ApiException
import com.distasilucas.cryptobalancetracker.exception.TooManyRequestsException
import com.distasilucas.cryptobalancetracker.service.CoingeckoCryptoNotFoundException
import com.distasilucas.cryptobalancetracker.service.DuplicatedCryptoPlatFormException
import com.distasilucas.cryptobalancetracker.service.DuplicatedGoalException
import com.distasilucas.cryptobalancetracker.service.DuplicatedPlatformException
import com.distasilucas.cryptobalancetracker.service.DuplicatedPriceTargetException
import com.distasilucas.cryptobalancetracker.service.GoalNotFoundException
import com.distasilucas.cryptobalancetracker.service.InsufficientBalanceException
import com.distasilucas.cryptobalancetracker.service.PlatformNotFoundException
import com.distasilucas.cryptobalancetracker.service.PriceTargetNotFoundException
import com.distasilucas.cryptobalancetracker.service.UserCryptoNotFoundException
import com.distasilucas.cryptobalancetracker.service.UsernameNotFoundException
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.validation.ConstraintViolationException
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.security.access.AccessDeniedException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.MissingServletRequestParameterException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.context.request.ServletWebRequest
import org.springframework.web.context.request.WebRequest
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.net.URI

<span class="fc" id="L34">@RestControllerAdvice</span>
class ExceptionController {

<span class="pc" id="L37">  private val logger = KotlinLogging.logger { }</span>
<span class="fc" id="L38">  private val NOT_FOUND_STATUS = HttpStatus.NOT_FOUND</span>
<span class="fc" id="L39">  private val BAD_REQUEST_STATUS = HttpStatus.BAD_REQUEST</span>

  @ExceptionHandler(PlatformNotFoundException::class)
  fun handlePlatformNotFoundException(
    exception: PlatformNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L46">    logger.info { &quot;A PlatformNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L48">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L49">    val problemDetail =</span>
<span class="fc" id="L50">      NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L52">    return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(CoingeckoCryptoNotFoundException::class)
  fun handleCoingeckoCryptoNotFoundException(
    exception: CoingeckoCryptoNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L60">    logger.info { &quot;A CoingeckoCryptoNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L62">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L63">    val problemDetail =</span>
<span class="fc" id="L64">      NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L66">    return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(UserCryptoNotFoundException::class)
  fun handleUserCryptoNotFoundException(
    exception: UserCryptoNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L74">    logger.info { &quot;A UserCryptoNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L76">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L77">    val problemDetail =</span>
<span class="fc" id="L78">      NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L80">    return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(GoalNotFoundException::class)
  fun handleGoalNotFoundException(
    exception: GoalNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L88">    logger.info { &quot;A GoalNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L90">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L91">    val problemDetail =</span>
<span class="fc" id="L92">      NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L94">    return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(PriceTargetNotFoundException::class)
  fun handlePriceTargetNotFoundException(
    exception: PriceTargetNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L102">    logger.info { &quot;A PriceTargetNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L104">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L105">    val problemDetail =</span>
<span class="fc" id="L106">      NOT_FOUND_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L108">    return ResponseEntity.status(NOT_FOUND_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(DuplicatedPriceTargetException::class)
  fun handleDuplicatedPriceTargetException(
    exception: DuplicatedPriceTargetException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L116">    logger.info { &quot;A DuplicatedPriceTargetException occurred $exception&quot; }</span>

<span class="fc" id="L118">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L119">    val problemDetail =</span>
<span class="fc" id="L120">      BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L122">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(DuplicatedPlatformException::class)
  fun handleDuplicatedPlatformException(
    exception: DuplicatedPlatformException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L130">    logger.info { &quot;A DuplicatedPlatformException occurred $exception&quot; }</span>

<span class="fc" id="L132">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L133">    val problemDetail =</span>
<span class="fc" id="L134">      BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L136">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(DuplicatedCryptoPlatFormException::class)
  fun handleDuplicatedCryptoPlatFormException(
    exception: DuplicatedCryptoPlatFormException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L144">    logger.info { &quot;A DuplicatedCryptoPlatFormException occurred $exception&quot; }</span>

<span class="fc" id="L146">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L147">    val problemDetail =</span>
<span class="fc" id="L148">      BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L150">    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(DuplicatedGoalException::class)
  fun handleDuplicatedGoalException(
    exception: DuplicatedGoalException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L158">    logger.info { &quot;A DuplicatedGoalException occurred $exception&quot; }</span>

<span class="fc" id="L160">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L161">    val problemDetail =</span>
<span class="fc" id="L162">      BAD_REQUEST_STATUS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L164">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(InsufficientBalanceException::class)
  fun handleInsufficientBalanceException(
    exception: InsufficientBalanceException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L172">    logger.info { &quot;An InsufficientBalanceException occurred $exception&quot; }</span>

<span class="fc" id="L174">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L175">    val problemDetail =</span>
<span class="fc" id="L176">      HttpStatus.BAD_REQUEST.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L178">    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(UsernameNotFoundException::class)
  fun handleUsernameNotFoundException(
    exception: UsernameNotFoundException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L186">    logger.info { &quot;An UsernameNotFoundException occurred $exception&quot; }</span>

<span class="fc" id="L188">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L189">    val problemDetail =</span>
<span class="fc" id="L190">      HttpStatus.NOT_FOUND.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L192">    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(TooManyRequestsException::class)
  fun handleTooManyRequestsException(
    exception: TooManyRequestsException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L200">    logger.warn { &quot;A TooManyRequestsException occurred $exception&quot; }</span>

<span class="fc" id="L202">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L203">    val problemDetail =</span>
<span class="fc" id="L204">      HttpStatus.TOO_MANY_REQUESTS.withDetailsAndURI(exception.message!!, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L206">    return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(MethodArgumentNotValidException::class)
  fun handleMethodArgumentNotValidException(
    exception: MethodArgumentNotValidException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L214">    logger.info { &quot;A MethodArgumentNotValidException occurred $exception&quot; }</span>

<span class="fc" id="L216">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L217">    val problemDetails = exception.allErrors.map {</span>
<span class="fc" id="L218">      HttpStatus.BAD_REQUEST.withDetailsAndURI(</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        it.defaultMessage ?: UNKNOWN_ERROR,</span>
<span class="fc" id="L220">        URI.create(request.requestURL.toString())</span>
<span class="fc" id="L221">      )</span>
    }

<span class="fc" id="L224">    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problemDetails)</span>
  }

  @ExceptionHandler(HttpMessageNotReadableException::class)
  fun handleHttpMessageNotReadableException(
    exception: HttpMessageNotReadableException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L232">    logger.info { &quot;A HttpMessageNotReadableException occurred $exception&quot; }</span>

<span class="fc" id="L234">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L235">    val problemDetail = ProblemDetail.forStatus(BAD_REQUEST_STATUS)</span>
<span class="fc" id="L236">    problemDetail.type = URI.create(request.requestURL.toString())</span>

<span class="fc" id="L238">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(ConstraintViolationException::class)
  fun handleConstraintViolationException(
    exception: ConstraintViolationException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L246">    logger.info { &quot;A ConstraintViolationException occurred $exception&quot; }</span>

<span class="fc" id="L248">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L249">    val constraintViolations = exception.constraintViolations.toList()</span>

<span class="fc" id="L251">    val problemDetails = constraintViolations.map {</span>
<span class="fc" id="L252">      BAD_REQUEST_STATUS.withDetailsAndURI(it.message, URI.create(request.requestURL.toString()))</span>
    }

<span class="fc" id="L255">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(problemDetails)</span>
  }

  @ExceptionHandler(MissingServletRequestParameterException::class)
  fun handleMissingServletRequestParameterException(
    exception: MissingServletRequestParameterException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L263">    logger.info { &quot;A MissingServletRequestParameterException occurred $exception&quot; }</span>

<span class="fc" id="L265">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">    val detail = exception.body.detail ?: exception.message</span>
<span class="fc" id="L267">    val problemDetail = BAD_REQUEST_STATUS.withDetailsAndURI(detail, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L269">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(AccessDeniedException::class)
  fun handleAccessDeniedException(
    exception: AccessDeniedException,
    webRequest: WebRequest
  ): ResponseEntity&lt;ProblemDetail&gt; {
<span class="fc" id="L277">    logger.info { &quot;An AccessDeniedException occurred $exception&quot; }</span>

<span class="fc" id="L279">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">    val detail = exception.message ?: &quot;Forbidden&quot;</span>
<span class="fc" id="L281">    val problemDetail = HttpStatus.FORBIDDEN.withDetailsAndURI(detail, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L283">    return ResponseEntity.status(HttpStatus.FORBIDDEN).body(problemDetail)</span>
  }

  @ExceptionHandler(MethodArgumentTypeMismatchException::class)
  fun handleMethodArgumentTypeMismatchException(
    exception: MethodArgumentTypeMismatchException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L291">    logger.info { &quot;A MethodArgumentTypeMismatchException occurred $exception&quot; }</span>

<span class="fc" id="L293">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L294">    val name = exception.name</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">    val availableValues = exception.requiredType?.let { it.enumConstants.contentToString() }</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    val message = if (availableValues != null) {</span>
<span class="fc" id="L297">      INVALID_VALUE_FOR.format(exception.value, name, availableValues)</span>
    } else {
<span class="fc" id="L299">      &quot;Invalid value ${exception.value} for $name&quot;</span>
    }
<span class="fc" id="L301">    val problemDetail = BAD_REQUEST_STATUS.withDetailsAndURI(message, URI.create(request.requestURL.toString()))</span>

<span class="fc" id="L303">    return ResponseEntity.status(BAD_REQUEST_STATUS).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(ApiException::class)
  fun handleApiException(
    exception: ApiException,
    webRequest: WebRequest
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L311">    logger.warn { &quot;An ApiException occurred $exception&quot; }</span>

<span class="fc" id="L313">    val request = (webRequest as ServletWebRequest).request</span>
<span class="fc" id="L314">    val httpStatusCode = exception.httpStatusCode</span>

<span class="fc" id="L316">    val problemDetail = ProblemDetail.forStatusAndDetail(httpStatusCode, exception.message)</span>
<span class="fc" id="L317">    problemDetail.type = URI.create(request.requestURL.toString())</span>

<span class="fc" id="L319">    return ResponseEntity.status(httpStatusCode).body(listOf(problemDetail))</span>
  }

  @ExceptionHandler(Exception::class)
  fun handleException(
    exception: Exception
  ): ResponseEntity&lt;List&lt;ProblemDetail&gt;&gt; {
<span class="fc" id="L326">    logger.error { &quot;An unhandled Exception occurred $exception&quot; }</span>

<span class="fc" id="L328">    val problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.INTERNAL_SERVER_ERROR, UNKNOWN_ERROR)</span>

<span class="fc" id="L330">    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(listOf(problemDetail))</span>
  }

  private fun HttpStatus.withDetailsAndURI(
    detail: String,
    type: URI
  ): ProblemDetail {
<span class="fc" id="L337">    val problemDetail = ProblemDetail.forStatusAndDetail(this, detail)</span>
<span class="fc" id="L338">    problemDetail.type = type</span>

<span class="fc" id="L340">    return problemDetail</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>